**为什么学习数据结构与算法**

1. 学任何知识都是为了用的，是为了解决实际工作问题的
2. 常用的基础框架中，比如spring、RPC框架、消息中间件、Redis等等，都揉合了很多基础数据结构和算法的设计思想，掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的。
3. 基础架构研发工程师，写出达到开源水平的框架才是目标
4. 对编程还有追求，不想被行业淘汰，就不要只会写凑合能用的代码。性能好坏是其中一个非常重要的评判标准。

**学习技巧**

1. 边学边练，适度刷题
2. 多问、多思考、多互动
3. 知识需要沉淀，不要想试图一下子掌握所有

**为什么需要复杂度分析**

1. 测试结果非常依赖测试环境
2. 测试结果受数据规模的影响很大

**时间复杂度**

1. 只关注循环执行次数最多的一段代码

   ```
    int cal(int n) {
      int sum = 0;
      int i = 1;
      for (; i <= n; ++i) {
        sum = sum + i;
      }
      return sum;
    }
   ```

   第2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第4、5行代码。这两行代码被执行了n次，所以总的时间负责度就是O(n)。

2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

   ```
   int cal(int n) {
      int sum_1 = 0;
      int p = 1;
      for (; p < 100; ++p) {
        sum_1 = sum_1 + p;
      }
    
      int sum_2 = 0;
      int q = 1;
      for (; q < n; ++q) {
        sum_2 = sum_2 + q;
      }
    
      int sum_3 = 0;
      int i = 1;
      int j = 1;
      for (; i <= n; ++i) {
        j = 1; 
        for (; j <= n; ++j) {
          sum_3 = sum_3 +  i * j;
        }
      }
    
      return sum_1 + sum_2 + sum_3;
    }
   ```

   这段代码分为三部分，分别是求sum_1、sum_2、sum_3。

   第一段是一个常量的执行时间，与n的规模无关。

   第二段时间负责度为O(n)。

   第三段时间负责度为O(n^2)。

   所以总的时间负责度为O(n^2)。

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

   ```
   int cal(int n) {
      int ret = 0; 
      int i = 1;
      for (; i < n; ++i) {
        ret = ret + f(i);
      } 
    } 
    
    int f(int n) {
     int sum = 0;
     int i = 1;
     for (; i < n; ++i) {
       sum = sum + i;
     } 
     return sum;
    }
   ```

   cal() 第4-6行的时间复杂度就是O(n),f() 的时间复杂度为O(n)，所以cal() 总的时间复杂度为O(n*n) = O(n^2)。

4. 常见时间复杂度

   常量阶: O(1)

   指数阶: O (2^n)

   对数阶: O(logn)

   阶乘阶: O(n!)

   线性阶: O(n)

   线性对数阶: O(nlogn)

   平方阶: O(n^2)

**空间复杂度**

​	表示算法的存储空间与数据规模之间的增长关系